'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utilInvariant = require('@onflow/util-invariant');
var utilLogger = require('@onflow/util-logger');
var fclCore = require('@onflow/fcl-core');
var SignClient = require('@walletconnect/sign-client');
require('@walletconnect/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fclCore__namespace = /*#__PURE__*/_interopNamespace(fclCore);
var SignClient__default = /*#__PURE__*/_interopDefaultLegacy(SignClient);

function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}
function openDeeplink(url) {
  if (url.startsWith("http")) {
    // Workaround for https://github.com/rainbow-me/rainbowkit/issues/524.
    // Using 'window.open' causes issues on iOS in non-Safari browsers and
    // WebViews where a blank tab is left behind after connecting.
    // This is especially bad in some WebView scenarios (e.g. following a
    // link from Twitter) where the user doesn't have any mechanism for
    // closing the blank tab.
    // For whatever reason, links with a target of "_blank" don't suffer
    // from this problem, and programmatically clicking a detached link
    // element with the same attributes also avoids the issue.
    const link = document.createElement("a");
    link.href = url;
    link.target = "_blank";
    link.rel = "noreferrer noopener";
    link.click();
  } else {
    window.open(url, "_blank");
  }
}

let FLOW_METHODS = /*#__PURE__*/function (FLOW_METHODS) {
  FLOW_METHODS["FLOW_AUTHN"] = "flow_authn";
  FLOW_METHODS["FLOW_PRE_AUTHZ"] = "flow_pre_authz";
  FLOW_METHODS["FLOW_AUTHZ"] = "flow_authz";
  FLOW_METHODS["FLOW_USER_SIGN"] = "flow_user_sign";
  return FLOW_METHODS;
}({});
let REQUEST_TYPES = /*#__PURE__*/function (REQUEST_TYPES) {
  REQUEST_TYPES["SESSION_REQUEST"] = "session_proposal";
  REQUEST_TYPES["SIGNING_REQUEST"] = "signing_request";
  return REQUEST_TYPES;
}({});

// Create a new session proposal with the WalletConnect client
async function createSessionProposal(_ref) {
  let {
    client,
    existingPairing
  } = _ref;
  const network = await fclCore__namespace.getChainId();
  const requiredNamespaces = {
    flow: {
      methods: [FLOW_METHODS.FLOW_AUTHN, FLOW_METHODS.FLOW_PRE_AUTHZ, FLOW_METHODS.FLOW_AUTHZ, FLOW_METHODS.FLOW_USER_SIGN],
      chains: [`flow:${network}`],
      events: ["chainChanged", "accountsChanged"]
    }
  };
  const {
    uri,
    approval
  } = await client.connect({
    pairingTopic: existingPairing?.topic,
    requiredNamespaces
  });
  if (!uri) {
    throw new Error("FCL-WC: Error creating session proposal. Could not create a proposal URI.");
  }
  return {
    uri,
    approval
  };
}
const request = async _ref2 => {
  let {
    method,
    body,
    session,
    client,
    abortSignal
  } = _ref2;
  const [chainId, addr, address] = makeSessionData(session);
  const data = JSON.stringify({
    ...body,
    addr,
    address
  });
  const result = await Promise.race([client.request({
    topic: session.topic,
    chainId,
    request: {
      method,
      params: [data]
    }
  }), new Promise((_, reject) => {
    if (abortSignal?.aborted) {
      reject(new Error("WalletConnect Request aborted"));
    }
    abortSignal?.addEventListener("abort", () => {
      reject(new Error("WalletConnect Request aborted"));
    });
  })]);
  if (typeof result !== "object" || result == null) return;
  switch (result.status) {
    case "APPROVED":
      return result.data;
    case "DECLINED":
      throw new Error(`Declined: ${result.reason || "No reason supplied"}`);
    case "REDIRECT":
      return result.data;
    default:
      throw new Error(`Declined: No reason supplied`);
  }
};
function makeSessionData(session) {
  const [namespace, reference, address] = Object.values(session.namespaces).map(namespace => namespace.accounts).flat().filter(account => account.startsWith("flow:"))[0].split(":");
  const chainId = `${namespace}:${reference}`;
  const addr = address;
  return [chainId, addr, address];
}

const SERVICE_PLUGIN_NAME = "fcl-plugin-service-walletconnect";
const WC_SERVICE_METHOD = "WC/RPC";
const makeServicePlugin = function (client) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    projectId: "",
    includeBaseWC: false,
    wallets: [],
    wcRequestHook: null,
    pairingModalOverride: null
  };
  return {
    name: SERVICE_PLUGIN_NAME,
    f_type: "ServicePlugin",
    type: "discovery-service",
    serviceStrategy: {
      method: WC_SERVICE_METHOD,
      exec: makeExec(client, opts, import('@walletconnect/modal').then(m => m.WalletConnectModal))
    },
    services: []
  };
};
const makeExec = (clientPromise, _ref, WalletConnectModal) => {
  let {
    wcRequestHook,
    pairingModalOverride
  } = _ref;
  return async _ref2 => {
    let {
      service,
      body,
      opts,
      abortSignal
    } = _ref2;
    const client = await clientPromise;
    utilInvariant.invariant(!!client, "WalletConnect is not initialized");
    let session, pairing;
    const method = service.endpoint;
    const appLink = validateAppLink(service);
    const pairings = client.pairing.getAll({
      active: true
    });
    if (pairings.length > 0) {
      pairing = pairings?.find(p => p.peerMetadata?.url === service.uid);
    }
    if (client.session.length > 0) {
      const lastKeyIndex = client.session.keys.length - 1;
      session = client.session.get(client.session.keys.at(lastKeyIndex));
    }
    if (session == null) {
      session = await new Promise((resolve, reject) => {
        function onClose() {
          reject(`Declined: Externally Halted`);
        }
        connectWc(WalletConnectModal)({
          service,
          onClose,
          appLink,
          client,
          method,
          pairing,
          wcRequestHook,
          pairingModalOverride,
          abortSignal
        }).then(resolve, reject);
      });
    }
    if (wcRequestHook && wcRequestHook instanceof Function) {
      wcRequestHook({
        type: REQUEST_TYPES.SIGNING_REQUEST,
        method,
        service,
        session: session ?? null,
        pairing: pairing ?? null,
        uri: null
      });
    }
    if (isMobile() && method !== FLOW_METHODS.FLOW_AUTHN && !(method === FLOW_METHODS.FLOW_AUTHZ && opts.initiatedByPreAuthz)) {
      openDeeplink(appLink);
    }

    // Make request to the WalletConnect client and return the result
    return await request({
      method,
      body,
      session,
      client,
      abortSignal
    });
    function validateAppLink(_ref3) {
      let {
        uid
      } = _ref3;
      if (!(uid && /^(ftp|http|https):\/\/[^ "]+$/.test(uid))) {
        utilLogger.log({
          title: "WalletConnect Service Warning",
          message: `service.uid should be a valid universal link url. Found: ${uid}`,
          level: utilLogger.LEVELS.warn
        });
      }
      return uid;
    }
  };
};

// Connect to WalletConnect directly from the browser via deep link or WalletConnectModal
function connectWc(WalletConnectModal) {
  return async _ref4 => {
    let {
      service,
      onClose,
      appLink,
      client,
      method,
      pairing,
      wcRequestHook,
      pairingModalOverride,
      abortSignal
    } = _ref4;
    const projectId = client.opts?.projectId;
    utilInvariant.invariant(!!projectId, "Cannot establish connection, WalletConnect projectId is undefined");
    let _uri = null,
      walletConnectModal;
    try {
      const {
        uri,
        approval
      } = await createSessionProposal({
        client,
        existingPairing: pairing
      });
      _uri = uri;
      if (wcRequestHook && wcRequestHook instanceof Function) {
        wcRequestHook({
          type: REQUEST_TYPES.SESSION_REQUEST,
          method,
          service,
          session: null,
          pairing: pairing ?? null,
          uri: uri ?? null
        });
      }
      if (isMobile()) {
        const queryString = new URLSearchParams({
          uri: uri
        }).toString();
        let url = pairing == null ? appLink + "?" + queryString : appLink;
        openDeeplink(url);
      } else if (!pairing) {
        if (!pairingModalOverride) {
          walletConnectModal = new (await WalletConnectModal)({
            projectId,
            walletConnectVersion: 2
          });
          walletConnectModal.openModal({
            uri,
            onClose
          });
        } else {
          pairingModalOverride(uri, onClose);
        }
      }
      const session = await Promise.race([approval(), new Promise((_, reject) => {
        if (abortSignal?.aborted) {
          reject(new Error("Session request aborted"));
        }
        abortSignal?.addEventListener("abort", () => {
          reject(new Error("Session request aborted"));
        });
      })]);
      return session;
    } catch (error) {
      if (error instanceof Error) {
        utilLogger.log({
          title: `${error.name} Error establishing WalletConnect session`,
          message: `
          ${error.message}
          uri: ${_uri}
        `,
          level: utilLogger.LEVELS.error
        });
      }
      onClose();
      throw error;
    } finally {
      walletConnectModal?.closeModal();
    }
  };
}

const DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
const DEFAULT_LOGGER = "debug";
let clientPromise = Promise.resolve(null);
const initClient = async _ref => {
  let {
    projectId,
    metadata
  } = _ref;
  utilInvariant.invariant(projectId != null, "FCL Wallet Connect Error: WalletConnect projectId is required");
  try {
    return SignClient__default["default"].init({
      logger: DEFAULT_LOGGER,
      relayUrl: DEFAULT_RELAY_URL,
      projectId: projectId,
      metadata: metadata
    });
  } catch (error) {
    if (error instanceof Error) {
      utilLogger.log({
        title: `${error.name} fcl-wc Init Client`,
        message: error.message,
        level: utilLogger.LEVELS.error
      });
    }
    throw error;
  }
};
const initLazy = config => {
  const {
    FclWcServicePlugin,
    clientPromise
  } = initHelper(config);
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    clientPromise
  };
};
const init = async config => {
  const {
    FclWcServicePlugin,
    clientPromise
  } = initLazy(config);
  const client = await clientPromise;
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    client
  };
};
const initHelper = _ref2 => {
  let {
    projectId,
    metadata,
    includeBaseWC = false,
    wcRequestHook = null,
    pairingModalOverride = null,
    wallets = []
  } = _ref2;
  if (typeof window === "undefined") {
    throw new Error("FCL Wallet Connect Plugin can only be initialized in the browser");
  }

  // Lazy load the SignClient
  //  - Initialize the client if it doesn't exist
  //  - If it does exist, return existing client
  //  - If existing client fails to initialize, reinitialize
  clientPromise = Promise.resolve(clientPromise).catch(() => null).then(_client => {
    if (_client) {
      return _client;
    } else {
      return initClient({
        projectId,
        metadata
      });
    }
  }).catch(e => {
    utilLogger.log({
      title: `WalletConnect Client Initialization Error`,
      message: e.message ? e.message : e,
      level: utilLogger.LEVELS.error
    });
    throw e;
  });
  const FclWcServicePlugin = makeServicePlugin(clientPromise, {
    projectId,
    includeBaseWC,
    wcRequestHook,
    pairingModalOverride,
    wallets
  });
  return {
    FclWcServicePlugin,
    clientPromise
  };
};

// Returns the SignClient instance used by this plugin if it has been initialized
async function getSignClient() {
  return clientPromise.then(client => {
    if (!client) {
      throw new Error("WalletConnect client not initialized");
    }
    return client;
  });
}

exports.FLOW_METHODS = FLOW_METHODS;
exports.SERVICE_PLUGIN_NAME = SERVICE_PLUGIN_NAME;
exports.WC_SERVICE_METHOD = WC_SERVICE_METHOD;
exports.createSessionProposal = createSessionProposal;
exports.getSignClient = getSignClient;
exports.init = init;
exports.initLazy = initLazy;
exports.request = request;
//# sourceMappingURL=index.js.map
