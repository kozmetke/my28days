!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@onflow/sdk"),require("@onflow/types"),require("@onflow/util-invariant"),require("cross-fetch"),require("@onflow/config"),require("@onflow/util-logger"),require("@onflow/util-address"),require("@onflow/rlp"),require("@onflow/util-actor"),require("@onflow/transport-http"),require("@improbable-eng/grpc-web"),require("sha3"),require("@onflow/util-template"),require("@onflow/util-semver")):"function"==typeof define&&define.amd?define(["exports","@onflow/sdk","@onflow/types","@onflow/util-invariant","cross-fetch","@onflow/config","@onflow/util-logger","@onflow/util-address","@onflow/rlp","@onflow/util-actor","@onflow/transport-http","@improbable-eng/grpc-web","sha3","@onflow/util-template","@onflow/util-semver"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["onflowFcl-core"]={},e.sdk,e.t,e.utilInvariant,e.fetchTransport,e.config,e.logger,e.utilAddress,e.rlp,e.utilActor,e.transportHttp,e.grpcWeb,e.sha3,e.utilTemplate,e.semver)}(this,(function(e,t,n,r,a,i,o,s,c,l,d,u,p,f,m){"use strict";function g(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function y(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var v=y(t),h=y(n),b=g(a),w=y(o),E=y(c),P=y(m);const S="1.12.0",I=e=>t=>typeof t===e,T=e=>null!=e,C=I("object"),A=I("string"),k=I("function"),R=I("number");function O(e){return k(e)?e(v.arg,h):[]}async function _(e){let t,{url:n}=e;r.invariant(void 0!==n,"retrieve({ url }) -- url must be defined");try{t=await b.default(n)}catch(e){throw new Error("httpDocumentResolver Error: Failed to retrieve document.")}return t.ok?await t.json():null}const N=new Map([["http",_],["https",_]]);async function j(e){let{network:t,template:n}=e;r.invariant("1.1.0"===n.f_version,"deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0");const a={};return n?.data?.dependencies.forEach((e=>{e.contracts.forEach((e=>{const n=e.contract;e.networks.forEach((e=>{e.network===t&&(a[n]=e.address)})),r.invariant(void 0!==a[n],`deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${t} ${n}`)}))})),r.invariant(Object.keys(a).length===n?.data?.dependencies.length,`deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${a}`),r.invariant(Object.keys(a).length===Object.values(a).length,`deriveCadenceByNetwork110 -- Could not find all addresses for network ${t} dependencies:  ${a}`),r.invariant(n?.data?.cadence?.body,`no cadence found -- Could not replace import dependencies: ${a}`),function(e){let{cadence:t,networkDependencies:n}=e;return Object.keys(n).reduce(((e,t)=>{const r=n[t],a=new RegExp(`import "\\b${t}\\b"`,"g");return e.replace(a,`import ${t} from ${r}`)}),t)}({cadence:n?.data?.cadence?.body,networkDependencies:a})}async function L(e){let{network:t,template:n}=e;switch(r.invariant(null!=t,"deriveCadenceByNetwork({ network }) -- network must be defined"),r.invariant("string"==typeof t,"deriveCadenceByNetwork({ network }) -- network must be a string"),r.invariant(null!=n,"deriveCadenceByNetwork({ template }) -- template must be defined"),r.invariant("object"==typeof n,"deriveCadenceByNetwork({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate"),n.f_version){case"1.1.0":return await j({network:t,template:n});case"1.0.0":return await async function(e){let{network:t,template:n}=e;return r.invariant("1.0.0"===n.f_version,"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0"),Object.keys(n?.data?.dependencies).map((e=>{const a=Object.values(n?.data?.dependencies?.[e]);r.invariant(void 0!==a,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`),r.invariant(a.length>0,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`);const i=a[0],o=i?.[t];return r.invariant(o,`deriveCadenceByNetwork100 -- Could not find ${t} network information for dependency: ${e}`),[e,o?.address]})).reduce(((e,t)=>{let[n,r]=t;const a=new RegExp("(\\b"+n+"\\b)","g");return e.replace(a,r)}),n.data.cadence)}({network:t,template:n});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}let x={},U=!1;async function D(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=await i.config.get("flow.network"),n=await i.config.get("env");n&&!U&&(o.log.deprecate({pkg:"FCL",subject:'Using the "env" configuration key for specifying the flow network',message:"Configuring to specify flow network is no longer required",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"}),U=!0);const r=e.node||await i.config.get("accessNode.api");if(!r){if(t)return t;if(n)return n;throw new Error('Either the "accessNode.api" config key or opts.node must be set')}if(x[r])try{return await x[r]}catch{}x[r]||(x[r]=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(await v.send([v.getNetworkParameters()],e).then(v.decode)).chainId}(e).catch((e=>{throw x[r]=null,e})));try{return await x[r]}catch(e){if(t)return t;if(n)return n;throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`)}}async function F(e){A(e?.template)&&(e.template=await async function(e){let{url:t}=e;r.invariant(void 0!==t,"retrieve({ url }) -- url must be defined"),r.invariant("string"==typeof t,"retrieve({ url }) -- url must be a string");const n=await i.config().where(/^document\.resolver\./);Object.keys(n).map((e=>{const t=n[e],r=e.replace(/^document\.resolver\./,"");N.set(r,t)}));const a=/^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(t);r.invariant(a,"Failed to parse URL");const o=a[1];r.invariant(a,"Failed to parse URL protocol");const s=N.get(o);return r.invariant(s,`No resolver found for protcol=${o}`),await s({url:t})}({url:e?.template}));const t=e.cadence||await L({template:e.template,network:await D(e)});return e.cadence=t,e}async function B(e,t){r.invariant(T(t),`${e}(opts) -- opts is required`),r.invariant(C(t),`${e}(opts) -- opts must be an object`),r.invariant(!(t.cadence&&t.template),`${e}({ template, cadence }) -- cannot pass both cadence and template`),r.invariant(T(t.cadence||t?.template),`${e}({ cadence }) -- cadence is required`),r.invariant(A(t.cadence)||t?.template,`${e}({ cadence }) -- cadence must be a string`),r.invariant(await v.config().get("accessNode.api"),`${e}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)}async function z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await async function(e){return B("query",e)}(e),e=await F(e),v.send([v.script(e.cadence),v.args(O(e.args||[])),e.limit&&"number"==typeof e.limit&&v.limit(e.limit)]).then(v.decode)}const $="fcl_redirect_url",M="fclResponseJson",H={"HTTP/RPC":"HTTP/RPC","HTTP/POST":"HTTP/POST","IFRAME/RPC":"IFRAME/RPC","POP/RPC":"POP/RPC","TAB/RPC":"TAB/RPC","EXT/RPC":"EXT/RPC","DEEPLINK/RPC":"DEEPLINK/RPC"},V=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{};const n=n=>{const{data:r}=n;"object"==typeof r&&null!=typeof r&&r.type===e&&t((e=>(e.deprecated&&console.warn("DEPRECATION NOTICE",e.deprecated.message),delete e?.body?.interaction,e))(r))};return window.addEventListener("message",n),()=>window.removeEventListener("message",n)};let q=!1;function W(){return q}const K=globalThis.URL;class G extends K{constructor(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];super(e,t,...r),W()&&this._url&&!e.endsWith("/")&&this._url.endsWith("/")&&(this._url=this._url.slice(0,-1))}}const J=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={...t,type:e},r=new URLSearchParams(window.location.search).get($);if(r){const e=new G(r);e.searchParams.append(M,JSON.stringify(n)),window.location.href=e.href}else if(window.location!==window.parent.location)window.parent.postMessage({...t,type:e},"*");else{if(!window.opener)throw new Error("Unable to communicate with parent FCL instance");window.opener.postMessage({...t,type:e},"*")}},Y={f_type:"Service",f_vsn:"1.0.0"},X={f_type:"Identity",f_vsn:"1.0.0"},Z={f_type:"USER",f_vsn:"1.0.0"},Q={f_type:"PollingResponse",f_vsn:"1.0.0"},ee={f_type:"CompositeSignature",f_vsn:"1.0.0"};const te=e=>{return t=e,n=8,c.Buffer.from(t.padStart(2*n,"0"),"hex");var t,n},ne=e=>c.Buffer.from(e,"hex"),re=function(e){let{address:t,nonce:n,appIdentifier:a}=e,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];r.invariant(t,"Encode Message For Provable Authn Error: address must be defined"),r.invariant(n,"Encode Message For Provable Authn Error: nonce must be defined"),r.invariant(a,"Encode Message For Provable Authn Error: appIdentifier must be defined"),r.invariant(n.length>=64,"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");const o=(l=c.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"),d=32,c.Buffer.from(l.padEnd(2*d,"0"),"hex"));var l,d;return i?c.Buffer.concat([o,c.encode([a,te(s.sansPrefix(t)),ne(n)])]).toString("hex"):c.encode([a,te(s.sansPrefix(t)),ne(n)]).toString("hex")};var ae=Object.freeze({__proto__:null,sendMsgToFCL:J,ready:function(e){V("FCL:VIEW:READY:RESPONSE",e),J("FCL:VIEW:READY")},close:()=>{J("FCL:VIEW:CLOSE")},approve:e=>{J("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"APPROVED",reason:null,data:e})},decline:e=>{J("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"DECLINED",reason:e,data:null})},redirect:e=>{J("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"REDIRECT",reason:null,data:e})},onMessageFromFCL:V,encodeMessageFromSignable:t.encodeMessageFromSignable,CompositeSignature:function(e,t,n){this.f_type=ee.f_type,this.f_vsn=ee.f_vsn,this.addr=s.withPrefix(e),this.keyId=Number(t),this.signature=n},encodeAccountProof:re,injectExtService:function(e){"authn"===e.type&&null!=e.endpoint?(Array.isArray(window.fcl_extensions)||(window.fcl_extensions=[]),window.fcl_extensions.push(e)):console.warn("Authn service is required")}});const ie=e=>{if(e.appIdentifier){const{appIdentifier:t,address:n,nonce:a,signatures:i}=e;return r.invariant(A(t),"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"),r.invariant(A(n)&&16===s.sansPrefix(n).length,"verifyAccountProof({ address }) -- address must be a valid address"),r.invariant(/^[0-9a-f]+$/i.test(a),"nonce must be a hex string"),r.invariant(Array.isArray(i)&&i.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(i.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}{const{message:t,address:n,compSigs:a}=e;return r.invariant(/^[0-9a-f]+$/i.test(t),"Signed message must be a hex string"),r.invariant(A(n)&&16===s.sansPrefix(n).length,"verifyUserSignatures({ address }) -- address must be a valid address"),r.invariant(Array.isArray(a)&&a.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(a.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}},oe=async(e,t)=>{const n="ACCOUNT_PROOF"===e?"verifyAccountProofSignatures":"verifyUserSignatures";let a=await D(t);const i=t.fclCryptoContract||{testnet:"0x74daa6f9c7ef24b1",mainnet:"0xb4b82a1c9d21d284",previewnet:"0x40b5b8b2ce81ea4a"}[a];return r.invariant(i,`${n}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${a}. Please manually specify the FCLCrypto contract address.`),`\n      import FCLCrypto from ${i}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${n}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `};async function se(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=s.withPrefix(t[0].addr);ie({message:e,address:r,compSigs:t});let a=[],i=[];for(const e of t)a.push(e.signature),i.push(e.keyId.toString());return z({cadence:await oe("USER_SIGNATURE",n),args:(t,n)=>[t(r,n.Address),t(e,n.String),t(i,n.Array(n.Int)),t(a,n.Array(n.String))]})}var ce=Object.freeze({__proto__:null,verifyAccountProof:async function(e,t){let{address:n,nonce:r,signatures:a}=t,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ie({appIdentifier:e,address:n,nonce:r,signatures:a});const o=re({address:n,nonce:r,appIdentifier:e},!1);let c=[],l=[];for(const e of a)c.push(e.signature),l.push(e.keyId.toString());return z({cadence:await oe("ACCOUNT_PROOF",i),args:(e,t)=>[e(s.withPrefix(n),t.Address),e(o,t.String),e(l,t.Array(t.Int)),e(c,t.Array(t.String))]})},verifyUserSignatures:se});const le=o.log.deprecate({pkg:"FCL",subject:"fcl.verifyUserSignatures()",message:"Please use fcl.AppUtils.verifyUserSignatures()",callback:function(e,t){return se(e,t)}});async function de(e){return Object.fromEntries(Object.entries(await i.config().where(e)).map((t=>{let[n,r]=t;return[n.replace(e,""),r]})))}const ue=/^[0-9a-fA-F]{64}$/,pe="POLL",fe="TIMEOUT",me=e=>e.status>=4,ge=e=>e.status>=3,ye=e=>e.status>=2,ve=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{[l.INIT]:async t=>{setTimeout((()=>t.sendSelf(fe)),e.txNotFoundTimeout),t.sendSelf(pe)},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,l.UPDATED,e.all())},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[l.SNAPSHOT]:async(e,t)=>{t.reply(e.all())},[fe]:async t=>{0===Object.keys(t.all()).length&&t.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${e.txNotFoundTimeout}ms)`))},[pe]:async n=>{const r=()=>setTimeout((()=>n.sendSelf(pe)),e.pollRate);let a;const i=n.all();try{a=await(async e=>t.send([t.getTransactionStatus(e)]).then(t.decode))(n.self())}catch(e){const t=e instanceof d.HTTPRequestError&&404===e.statusCode,a=e.code===u.grpc.Code.NotFound;return t||a?r():n.fatalError(e)}var o,s;me(a)||r(),o=i,s=a,JSON.stringify(o)!==JSON.stringify(s)&&n.broadcast(l.UPDATED,a),n.merge(a)}}},he=e=>{if("object"==typeof e&&(e=e.transactionId),null==e)throw new Error("transactionId required");return e},be=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>l.spawn(ve(e),he(t))};function we(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:2500};if(!ue.test(he(e)))throw new Error("Invalid transactionId");function n(n){return l.subscriber(he(e),be(t),n)}function r(e){return function(){const t=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).suppress||!1;return new Promise(((r,a)=>{const i=n(((n,o)=>{!o&&!n.statusCode||t?e(n)&&(r(n),i()):(a(o||n.errorMessage),i())}))}))}}return{snapshot:function(){return l.snapshoter(e,be(t))},subscribe:n,onceFinalized:r(ye),onceExecuted:r(ge),onceSealed:r(me)}}we.isUnknown=e=>e.status>=0,we.isPending=e=>e.status>=1,we.isFinalized=ye,we.isExecuted=ge,we.isSealed=me,we.isExpired=e=>5===e.status;const Ee="TICK",Pe="hwm",Se=async e=>setTimeout((()=>e.sendSelf(Ee)),await t.config().get("fcl.eventPollRate",1e4)),Ie={[Ee]:async e=>{if(!e.hasSubs())return;let n=e.get(Pe);if(null==n)e.put(Pe,await t.block()),e.put(Ee,await Se(e));else{let r=await t.block();if(e.put(Pe,r),n.height<r.height){const a=await t.send([t.getEventsAtBlockHeightRange(e.self(),n.height+1,r.height)]).then(t.decode);for(let t of a)e.broadcast("UPDATED",t.data)}e.put(Ee,await Se(e))}},[l.SUBSCRIBE]:async(e,t)=>{e.hasSubs()||e.put(Ee,await Se(e)),e.subscribe(t.from)},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from),e.hasSubs()||(clearTimeout(e.get(Ee)),e.delete(Ee),e.delete(Pe))}},Te=e=>l.spawn(Ie,e);const Ce=()=>{throw new Error("Platform specific Core Strategies are not initialized")},Ae={[H["EXT/RPC"]]:Ce,[H["HTTP/POST"]]:Ce,[H["IFRAME/RPC"]]:Ce,[H["POP/RPC"]]:Ce,[H["TAB/RPC"]]:Ce,[H["EXT/RPC"]]:Ce},ke=["ServicePlugin"],Re=["discovery-service"],Oe=e=>{let{coreStrategies:t}=e,n=new Set,a=new Map(Object.entries(t));const i=e=>n=new Set([...e]);return Object.freeze({add:e=>{if(r.invariant(Re.includes(e.type),`Service Plugin type ${e.type} is not supported`),"discovery-service"===e.type){const{discoveryServices:t,serviceStrategy:n}=(e=>{const{services:t=[],serviceStrategy:n}=e;r.invariant(Array.isArray(t),"Services must be an array");for(const e of t)r.invariant(T(e.f_type)&&"Service"===e.f_type,"Service is required"),r.invariant(T(e.type)&&"authn"===e.type,`Service must be type authn. Received ${e.type}`),r.invariant(e.method in H||n.method===e.method,`Service method ${e.method} is not supported`);return r.invariant(T(n),"Service strategy is required"),r.invariant(T(n.method)&&A(n.method),"Service strategy method is required"),r.invariant(T(n.exec)&&k(n.exec),"Service strategy exec function is required"),{discoveryServices:t,serviceStrategy:n}})(e);i(t),a.has(n.method)?o.log({title:"Add Service Plugin",message:`Service strategy for ${n.method} already exists`,level:o.LEVELS.warn}):a.set(n.method,n.exec)}},getServices:()=>[...n],getStrategy:e=>a.get(e),getStrategies:()=>[...a.keys()]})};let _e;const Ne=()=>void 0!==_e,je=e=>{let{coreStrategies:t}=e;if(Ne())return _e;const n=Oe({coreStrategies:t});return _e=n,n},Le=()=>Ne()?_e:(console.warn("Registry is not initalized, it will be initialized with stub core strategies"),je({coreStrategies:Ae})),xe=(()=>{const e=new Map;return Object.freeze({add:t=>{const n=(e=>{let t;r.invariant(!!e,"No plugins supplied"),t=Array.isArray(e)?[...e]:[e];for(const e of t)r.invariant(T(e.name),"Plugin name is required"),r.invariant(T(e.f_type),"Plugin f_type is required"),r.invariant(ke.includes(e.f_type),`Plugin type ${e.f_type} is not supported`);return t})(t);for(const t of n)e.set(t.name,t),"ServicePlugin"===t.f_type&&_e.add(t)},getPlugins:()=>e})})(),Ue=async()=>[...window?.fcl_extensions||[],...Le().getServices()];const De="authn",Fe="SNAPSHOT",Be="UPDATED",ze="UPDATE_RESULTS",$e=async()=>{try{const e=await async function(e){let{types:t}=e;const n=await i.config.get("discovery.authn.endpoint");r.invariant(Boolean(n),'"discovery.authn.endpoint" in config must be defined.');const a=await i.config.get("discovery.authn.include",[]),o=new G(n);return fetch(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:t,fclVersion:S,include:a,features:{suggested:await i.config.get("discovery.features.suggested",[])},clientServices:await Ue(),supportedStrategies:Le().getStrategies(),userAgent:window?.navigator?.userAgent,network:await D()})}).then((e=>e.json()))}({types:[De]});l.send(De,ze,{results:e})}catch(e){o.log({title:`${e.name} Error fetching Discovery API services.`,message:e.message,level:o.LEVELS.error})}},Me={[l.INIT]:async e=>{var t,n;t="undefined"==typeof window,n='"fcl.discovery" is only available in the browser.',t&&console.warn(`\n      %cFCL Warning\n      ============================\n      ${n}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,"font-weight:bold;font-family:monospace;"),"complete"===document.readyState?$e():window.addEventListener("load",(()=>{$e()}))},[ze]:(e,t,n)=>{e.merge(n),e.broadcast(Be,{...e.all()})},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,Be,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>e.unsubscribe(t.from),[Fe]:async(e,t)=>t.reply({...e.all()})},He=()=>l.spawn(Me,De),Ve={authn:{subscribe:e=>l.subscriber(De,He,e),snapshot:()=>l.snapshoter(De,He),update:()=>{"complete"===document.readyState&&$e()}}};function qe(e){const t=new p.SHA3(256);return t.update(c.Buffer.from(e,"utf8")),t.digest("hex")}function We(e){let{contractName:t,address:n}=e;return{contractName:t,address:n,contract:""}}function Ke(e){const t=[],n=e.match(/import ((\w|,| )+)* from 0x\w+/g)||[];for(const e of n){const n=/import ((\w+|, |)*) from (0x\w+)/g.exec(e),r=/((?:\w+)+),?/g,a=n[1].match(r)||[];for(const e of a)t.push(We({address:n[3],contractName:e.replace(/,/g,"")}))}return t}async function Ge(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[We({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Ke(e.contract);i.push(...r)}const o=i.map((e=>qe(e.contract)));return qe((await Promise.all(o)).join(""))}async function Je(e,t){const n=[];for(const r of t){const t=[qe(r.network)],{address:a,dependency_pin_block_height:i}=r;if(r.dependency_pin){const n=await Ge({address:a,contractName:e,blockHeight:i});t.push(qe(n))}n.push(t)}return n}async function Ye(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n],a=[];for(let e=0;e<r?.contracts.length;e++){const t=r?.contracts[e],n=t?.contract;a.push(qe(n));const i=await Je(n,t?.networks);a.push(i)}t.push(a)}return t}async function Xe(e){let{template:n}=e;switch(r.invariant(n,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),n.f_version){case"1.1.0":return await async function(e){let{template:t}=e;r.invariant(t,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof t,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===t.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),r.invariant("1.1.0"===t.f_version,"generateTemplateId({ template }) -- template object must be an version 1.1.0");const n=t.data,a=await Promise.all(n.messages.map((async e=>[qe(e.key),await Promise.all(e.i18n.map((async e=>[qe(e.tag),qe(e.translation)])))]))),i=await Promise.all(n?.parameters.sort(((e,t)=>e.index-t.index)).map((async e=>[qe(e.label),[qe(String(e.index)),qe(e.type),await Promise.all(e.messages.map((async e=>[qe(e.key),await Promise.all(e.i18n.map((async e=>[qe(e.tag),qe(e.translation)])))])))]]))),o=[await Ye(n?.dependencies)],s=c.encode([qe(t?.f_type),qe(t?.f_version),qe(n?.type),qe(n?.interface),a,qe(n?.cadence?.body),[o],i]).toString("hex");return qe(s)}({template:n});case"1.0.0":return await async function(e){let{template:n}=e;t.invariant(null!=n,"generateTemplateId({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),t.invariant("1.0.0"===n.f_version,"generateTemplateId({ template }) -- template object must be an version 1.0.0");const r=n.data,a=await Promise.all(Object.keys(r.messages).map((async e=>[qe(e),await Promise.all(Object.keys(r.messages?.[e]?.i18n).map((async t=>[qe(t),qe(r.messages?.[e]?.i18n?.[t])])))]))),i=await Promise.all(Object.keys(r?.dependencies).map((async e=>[qe(e),await Promise.all(Object.keys(r?.dependencies?.[e]).map((async t=>[qe(t),await Promise.all(Object.keys(r?.dependencies?.[e]?.[t]).map((async n=>[qe(n),[qe(r?.dependencies?.[e]?.[t]?.[n].address),qe(r?.dependencies?.[e]?.[t]?.[n].contract),qe(r?.dependencies?.[e]?.[t]?.[n].fq_address),qe(r?.dependencies?.[e]?.[t]?.[n].pin),qe(String(r?.dependencies?.[e]?.[t]?.[n].pin_block_height))]])))])))]))),o=await Promise.all(Object.keys(r?.arguments).map((async e=>[qe(e),[qe(String(r?.arguments?.[e].index)),qe(r?.arguments?.[e].type),qe(r?.arguments?.[e].balance||""),await Promise.all(Object.keys(r?.arguments?.[e].messages).map((async t=>[qe(t),await Promise.all(Object.keys(r?.arguments?.[e].messages?.[t].i18n).map((async n=>[qe(n),qe(r?.arguments?.[e].messages?.[t].i18n?.[n])])))])))]]))),s=c.encode([qe("InteractionTemplate"),qe("1.0.0"),qe(r?.type),qe(r?.interface),a,qe(r?.cadence),i,o]).toString("hex");return qe(s)}({template:n});default:throw new Error("generateTemplateId Error: Unsupported template version")}}async function Ze(e){let{version:n,address:r,contractName:a}=e;switch(t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string"),n){case"1.1.0":return await Ge({address:r,contractName:a});case"1.0.0":return await async function(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[We({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Ke(e.contract);i.push(...r)}const o=i.map((e=>qe(e.contract)));return qe(o.join(""))}({address:r,contractName:a});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}async function Qe(e){let{template:n,blockHeight:r,network:a}=e;switch(t.invariant(null!=n,"generateDependencyPin({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateDependencyPin({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateDependencyPin({ template }) -- template must be an InteractionTemplate"),t.invariant(null!=a,"generateDependencyPin({ network }) network must be defined"),t.invariant(null!=r,"generateDependencyPin({ blockHeight }) blockHeight must be defined"),t.invariant("number"==typeof r,"generateDependencyPin({ blockHeight }) blockHeight must be a number"),n.f_version){case"1.0.0":const e=Object.keys(n.data.dependencies);for(let t of e){const e=n.data.dependencies[t],i=Object.keys(e);for(let e of i){const i=n.data.dependencies[t][e][a];if(void 0===i)continue;const s=await Ze({address:i.address,contractName:i.contract,blockHeight:r});if(s!==i.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                address: ${i.address} | contract: ${i.contract}\n                                computed: ${s}\n                                template: ${i.pin}\n                            `,level:o.LEVELS.debug}),!1}}return!0;case"1.1.0":let t=!1;for(let e=0;e<n.data?.dependencies.length;e++){const i=n.data?.dependencies[e];for(let e=0;e<i?.contracts.length;e++){const s=i?.contracts[e];for(let e=0;e<s?.networks.length;e++){const i=s?.networks[e];if(i.network===a){const e=await Ze({version:n.f_version,address:i.address,contractName:s.contract,blockHeight:r});if(e!==i.dependency_pin.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                    address: ${i.address} | contract: ${s.contract}\n                                    computed: ${e}\n                                    template: ${i.pin}\n                                `,level:o.LEVELS.debug}),!1;t=!0}}}}return t;default:throw new Error("verifyDependencyPinsSame Error: Unsupported template version")}}var et=Object.freeze({__proto__:null,getInteractionTemplateAudits:async function(e){let{template:n,auditors:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"getInteractionTemplateAudits({ template }) -- template must be defined"),t.invariant("InteractionTemplate"===n.f_type,"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");let i=await Xe({template:n});if(i!==n.id)throw o.log({title:"getInteractionTemplateAudits Debug Error",message:`Could not recompute and match template ID\n                computed: ${i}\n                template: ${n.id}\n            `,level:o.LEVELS.debug}),new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");switch(n.f_version){case"1.1.0":case"1.0.0":const e=r||await t.config().get("flow.auditors");t.invariant(e,"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set"),t.invariant(Array.isArray(e),"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");let n=a.flowInteractionAuditContract;if(!n){const e=await D(a);t.invariant("mainnet"===e||"testnet"===e,"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'"),n="mainnet"===e?"0xfd100e39d50a13e6":"0xf78bfc12d0a786dc"}const o=await z({cadence:`\n        import FlowInteractionTemplateAudit from ${n}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,args:(t,n)=>[t(i,n.String),t(e,n.Array(n.Address))]});return o;default:throw new Error("getInteractionTemplateAudits Error: Unsupported template version")}},generateDependencyPin:Ze,generateDependencyPinAtLatestSealedBlock:async function(e){let{version:n,address:r,contractName:a}=e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=await t.block({sealed:!0},i),s=o?.height;return Ze({version:n,address:r,contractName:a,blockHeight:s})},generateTemplateId:Xe,verifyGeneratedTemplateId:async function(e){let{template:t}=e;return t.id===await Xe({template:t})},verifyDependencyPinsSame:Qe,verifyDependencyPinsSameAtLatestSealedBlock:async function(e){let{template:n,network:r}=e;const a=await t.block({sealed:!0}),i=a?.height;return Qe({template:n,network:r,blockHeight:i})},deriveCadenceByNetwork:L,getTemplateMessage:function(e){let{localization:n="en-US",messageKey:r,template:a}=e;switch(t.invariant(r,"getTemplateMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof r,"getTemplateMessage({ messageKey }) -- messageKey must be a string"),t.invariant(n,"getTemplateMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateMessage({ localization }) -- localization must be a string"),t.invariant(null!=a,"getTemplateMessage({ template }) -- template must be defined"),t.invariant("object"==typeof a,"getTemplateMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof a.f_type,"getTemplateMessage({ template }) -- template object must be an InteractionTemplate"),a.f_version){case"1.1.0":const e=a?.data?.messages?.find((e=>e.key===r));if(!e)return;const t=e?.i18n?.find((e=>e.tag===n));if(!t)return;return t.translation;case"1.0.0":return a?.data?.messages?.[r]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},getTemplateArgumentMessage:function(e){let{localization:n="en-US",argumentLabel:r,messageKey:a,template:i}=e;switch(t.invariant(a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string"),t.invariant(r,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string"),t.invariant(n,"getTemplateArgumentMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateArgumentMessage({ localization }) -- localization must be a string"),t.invariant(null!=i,"getTemplateArgumentMessage({ template }) -- template must be defined"),t.invariant("object"==typeof i,"getTemplateArgumentMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof i.f_type,"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate"),i.f_version){case"1.1.0":const e=i?.data?.parameters?.find((e=>e.label===r));if(!e)return;const t=e?.messages?.find((e=>e.key===a));if(!t)return;const o=t?.i18n?.find((e=>e.tag===n));if(!o)return;return o.translation;case"1.0.0":return i?.data?.arguments?.[r]?.messages?.[a]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}}});function tt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{old:e,...Y,type:"frame",endpoint:e.endpoint,params:e.params||{},data:e.data||{}}}function nt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:"back-channel-rpc",endpoint:e.endpoint,method:e.method,params:e.params||{},data:e.data||{}}}function rt(e){return null==e?null:(null==e.method&&(e={...e,type:"local-view",method:"VIEW/IFRAME"}),e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type||"local-view",method:e.method,endpoint:e.endpoint,data:e.data||{},params:e.params||{}})}function at(e,t){return e.map((e=>function(e,t){try{return it[e.type](e,t)}catch(t){return console.error(`Unrecognized FCL Service Type [${e.type}]`,e,t),e}}(e,t))).filter(Boolean)}const it={"back-channel-rpc":nt,"pre-authz":function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...X,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authz:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...X,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authn:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.authn,id:e.pid,provider:{address:s.withPrefix(e.addr),name:e.name,icon:e.icon}}},frame:tt,"open-id":function(e){return null==e?null:"1.0.0"===e.f_vsn?e:null},"user-signature":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid user-signature service");return"1.0.0"===e.f_vsn?e:null},"local-view":rt,"account-proof":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("FCL Normalizer Error: Invalid account-proof service");return"1.0.0"===e.f_vsn?e:null},"authn-refresh":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid authn-refresh service");return"1.0.0"===e.f_vsn?e:null}};function ot(){let e=arguments.length>1?arguments[1]:void 0;return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).reduce(((t,n)=>n.type===e&&(!t||P.compare(n.f_vsn,t.f_vsn)>0)?n:t),null)}function st(e){return E.encode([e.provider?.address||e.provider?.name||"UNSPECIFIED",e.id]).toString("hex")}async function ct(e){var t=at(function(){return[...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],...arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]]}((e=function(e){return e.addr=e.addr?s.withPrefix(e.addr):null,e.paddr=e.paddr?s.withPrefix(e.paddr):null,e}(e)).services||[],await async function(e,t){if(null==e||null==t)return[];const n=new G(e);n.searchParams.append("code",t);const r=await fetch(n,{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>e.json()));if(Array.isArray(r))return r;const a=[];if(Array.isArray(r.authorizations))for(let e of r.authorizations)a.push({type:"authz",keyId:r.keyId,...e});return null!=r.provider&&a.push({type:"authn",id:"wallet-provider#authn",...r.provider}),a}(e.hks,e.code)));const n=ot(t,"authn");return{...Z,addr:s.withPrefix(e.addr),cid:st(n),loggedIn:!0,services:t,expiresAt:e.expires}}const lt="WC/RPC",dt="undefined"==typeof window;const ut=globalThis.AbortController||require("abort-controller"),pt=async e=>{let{service:t,body:n,config:r,abortSignal:a,customRpc:i,opts:o}=e;return Le().getStrategy(t.method)({service:t,body:n,config:r,abortSignal:a,customRpc:i,opts:o})};async function ft(e){let{service:t,msg:n={},config:a={},opts:i={},platform:s,abortSignal:c=(new ut).signal,execStrategy:l}=e;!function(){if(dt)return;Le().getStrategies().includes(lt)||w.log({title:"FCL WalletConnect Service Plugin",level:w.LEVELS.error,message:"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."})}(),n.data=t.data;const d={services:await de(/^service\./),app:await de(/^app\.detail\./),client:{...a.client,platform:s,fclVersion:S,fclLibrary:"https://github.com/onflow/fcl-js",hostname:window?.location?.hostname??null,network:await D(i)}};try{const e=await(l||pt)({service:t,body:n,config:d,opts:i,abortSignal:c});return"REDIRECT"===e.status?(r.invariant(t.type===e.data.type,"Cannot shift recursive service type in execService"),await ft({service:e.data,msg:n,config:d,opts:i,abortSignal:c})):e}catch(e){throw o.log({title:`Error on execService ${t?.type}`,message:e,level:o.LEVELS.error}),e}}function mt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...ee,addr:s.sansPrefix(e.addr||e.address),signature:e.signature||e.sig,keyId:e.keyId}}const gt="CURRENT_USER",yt="CURRENT_USER/UPDATED",vt="SNAPSHOT",ht="SET_CURRENT_USER",bt="DEL_CURRENT_USER",wt='{\n  "f_type": "User",\n  "f_vsn": "1.0.0",\n  "addr":null,\n  "cid":null,\n  "loggedIn":null,\n  "expiresAt":null,\n  "services":[]\n}',Et={[l.INIT]:async e=>{"undefined"==typeof window&&console.warn('\n        %cFCL Warning\n        ============================\n        "currentUser" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ',"font-weight:bold;font-family:monospace;"),e.merge(JSON.parse(wt));const t=await i.config.first(["fcl.storage","fcl.storage.default"]);if(t.can){const n=await(async e=>{const t=JSON.parse(wt),n=await e.get(gt);return null!=n&&t.f_vsn!==n.f_vsn?(e.removeItem(gt),t):n||t})(t);(function(e){return null==e.expiresAt||0===e.expiresAt||e.expiresAt>Date.now()})(n)&&e.merge(n)}},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,yt,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[vt]:async(e,t)=>{t.reply({...e.all()})},[ht]:async(e,t,n)=>{e.merge(n);const r=await i.config.first(["fcl.storage","fcl.storage.default"]);r.can&&r.put(gt,e.all()),e.broadcast(yt,{...e.all()})},[bt]:async(e,t)=>{e.merge(JSON.parse(wt));const n=await i.config.first(["fcl.storage","fcl.storage.default"]);n.can&&n.put(gt,e.all()),e.broadcast(yt,{...e.all()})}},Pt=()=>l.spawn(Et,gt);const St=async e=>{let{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}=e;return{client:{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n,clientServices:await Ue(),supportedStrategies:Le().getStrategies()}}},It=e=>{let{platform:t,discovery:n}=e;return async function(){let{service:e,redir:a=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!e||e?.provider?.is_installed||!e?.provider?.requires_install)return new Promise((async(s,c)=>{Pt();const d={redir:a},u=await kt(),p=await async function(e){const t=await i.config.get("discovery.authn.include",[]),n=await i.config.get("discovery.features.suggested",[]),a=await i.config.first(["discovery.wallet.method","discovery.wallet.method.default"]),o=e?.method?e.method:a,s=e?.endpoint??await i.config.first(["discovery.wallet","challenge.handshake"]);return r.invariant(s,'\n    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.\n    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"\n    '),{...e,type:"authn",endpoint:s,method:o,discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}}(e),f=ot(u.services,"authn-refresh");let m;if(u.loggedIn){if(!f)return s(u);try{const e=await ft({service:f,msg:m,opts:d,platform:t});l.send(gt,ht,await ct(e))}catch(e){o.log({title:`${e.name} Could not refresh wallet authentication.`,message:e.message,level:o.LEVELS.error})}finally{return s(await kt())}}try{m=await async function(){let e=await i.config.get("fcl.accountProof.resolver");if(null==e)return;if("function"!=typeof e)return void o.log({title:"Account Proof Data Resolver must be a function",message:`Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof e}\n                `,level:o.LEVELS.warn});const t=await e();return null!=t?(r.invariant("string"==typeof t.appIdentifier,"appIdentifier must be a string"),r.invariant(/^[0-9a-f]+$/i.test(t.nonce),"Nonce must be a hex string"),t):void 0}()}catch(e){return o.log({title:`${e.name} On Authentication: Could not resolve account proof data.`,message:e.message,level:o.LEVELS.error}),c(e)}try{const e=await ft({service:p,msg:m,config:await St(p),opts:d,platform:t,execStrategy:n?.execStrategy});l.send(gt,ht,await ct(e))}catch(e){o.log({title:`${e} On Authentication`,message:e,level:o.LEVELS.error})}finally{s(await kt())}}));window.location.href=e?.provider?.install_link}};function Tt(){Pt(),l.send(gt,bt)}const Ct=e=>{let{platform:t,discovery:n}=e;return async e=>(Pt(),{...e,tempId:"CURRENT_USER",async resolve(e,r){const a=await It({platform:t,discovery:n})({redir:!0}),i=ot(a.services,"authz"),o=ot(a.services,"pre-authz");if(o)return(e=>{let{platform:t}=e;return e=>{const n=(e=>({f_type:"PreAuthzResponse",f_vsn:"1.0.0",proposer:(e||{}).proposer,payer:(e||{}).payer||[],authorization:(e||{}).authorization||[]}))(e),r=[];null!=n.proposer&&r.push(["PROPOSER",n.proposer]);for(let e of n.payer||[])r.push(["PAYER",e]);for(let e of n.authorization||[])r.push(["AUTHORIZER",e]);return r.map((e=>{let[n,r]=e;return{tempId:[r.identity.address,r.identity.keyId].join("|"),addr:r.identity.address,keyId:r.identity.keyId,signingFunction:e=>ft({service:r,msg:e,platform:t,opts:{initiatedByPreAuthz:!0}}),role:{proposer:"PROPOSER"===n,payer:"PAYER"===n,authorizer:"AUTHORIZER"===n}}}))}})({platform:t,discovery:n})(await ft({service:o,msg:r,platform:t}));if(i)return{...e,tempId:"CURRENT_USER",resolve:null,addr:s.sansPrefix(i.identity.address),keyId:i.identity.keyId,sequenceNum:null,signature:null,signingFunction:async e=>mt(await ft({service:i,msg:e,opts:{includeOlderJsonRpcCall:!0},platform:t}))};throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER")}})};function At(e){Pt();const t="@EXIT",n=l.spawn((async n=>{for(n.send(gt,l.SUBSCRIBE);;){const r=await n.receive();if(r.tag===t)return void n.send(gt,l.UNSUBSCRIBE);e(r.data)}}));return()=>l.send(n,t)}function kt(){return Pt(),l.send(gt,vt,null,{expectReply:!0,timeout:0})}const Rt=e=>{let{platform:n,discovery:r}=e;return async()=>{const{addr:e}=await It({platform:n,discovery:r})();return t.arg(s.withPrefix(e),h.Address)}},Ot=e=>(r.invariant(/^[0-9a-f]+$/i.test(e),"Message must be a hex string"),{message:e}),_t=e=>{let{platform:t,discovery:n}=e;return async e=>{Pt();const a=ot((await It({platform:t,discovery:n})({redir:!0})).services,"user-signature");r.invariant(a,"Current user must have authorized a signing service.");try{const n=await ft({service:a,msg:Ot(e),platform:t});return Array.isArray(n)?n.map((e=>mt(e))):[mt(n)]}catch(e){return e}}},Nt=e=>{let{platform:t,discovery:n}=e,r=()=>({authenticate:It({platform:t,discovery:n}),unauthenticate:Tt,authorization:Ct({platform:t,discovery:n}),signUserMessage:_t({platform:t,discovery:n}),subscribe:At,snapshot:kt,resolveArgument:Rt({platform:t,discovery:n})});return r.authenticate=It({platform:t,discovery:n}),r.unauthenticate=Tt,r.authorization=Ct({platform:t,discovery:n}),r.signUserMessage=_t({platform:t,discovery:n}),r.subscribe=At,r.snapshot=kt,r.resolveArgument=Rt({platform:t,discovery:n}),r};function jt(e){const t=new G(e.endpoint);if(window?.location?.origin&&t.searchParams.append("l6n",window.location.origin),null!=e.params)for(let[n,r]of Object.entries(e.params||{}))t.searchParams.append(n,r);return t}function Lt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=t.method||"POST",r="GET"===n?void 0:JSON.stringify(t.data||e.data||{});return fetch(jt(e),{method:n,headers:{...e.headers||{},...t.headers||{},"Content-Type":"application/json"},body:r}).then((e=>e.json()))}function xt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Q,status:e.status??"APPROVED",reason:e.reason??null,data:e.compositeSignature||e.data||{...e}||{},updates:nt(e.authorizationUpdates),local:tt((e.local||[])[0])}}const Ut={"HTTP/GET":"GET","HTTP/POST":"POST"},Dt=e=>(r.invariant(Ut[e.method],"Invalid Service Method for type back-channel-rpc",{service:e}),Ut[e.method]);async function Ft(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>!0;r.invariant(e,"Missing Polling Service",{service:e});if(!t())throw new Error("Externally Halted");let n;try{if("undefined"!=typeof document&&"hidden"===document.visibilityState)return await new Promise((e=>setTimeout(e,500))),Ft(e,t);n=await Lt(e,{method:Dt(e)}).then(xt)}catch(e){throw e}switch(n.status){case"APPROVED":return n.data;case"DECLINED":throw new Error(`Declined: ${n.reason||"No reason supplied."}`);default:return await new Promise((e=>setTimeout(e,500))),Ft(n.updates,t)}}const Bt="FCL:VIEW:CLOSE",zt="FCL:VIEW:READY",$t="FCL:VIEW:RESPONSE",Mt=e=>"string"==typeof e&&e.toLowerCase(),Ht=new Set(["monetizationstart","monetizationpending","monetizationprogress","monetizationstop"]),Vt=(e,t)=>console.warn("DEPRECATION NOTICE",`Received ${e}, please use ${t} for this and future versions of FCL`);i.config.subscribe((()=>{D({enableRequestLogging:!1}).catch((()=>{}))})),Object.defineProperty(e,"TestUtils",{enumerable:!0,get:function(){return t.TestUtils}}),Object.defineProperty(e,"account",{enumerable:!0,get:function(){return t.account}}),Object.defineProperty(e,"arg",{enumerable:!0,get:function(){return t.arg}}),Object.defineProperty(e,"args",{enumerable:!0,get:function(){return t.args}}),Object.defineProperty(e,"atBlockHeight",{enumerable:!0,get:function(){return t.atBlockHeight}}),Object.defineProperty(e,"atBlockId",{enumerable:!0,get:function(){return t.atBlockId}}),Object.defineProperty(e,"authorization",{enumerable:!0,get:function(){return t.authorization}}),Object.defineProperty(e,"authorizations",{enumerable:!0,get:function(){return t.authorizations}}),Object.defineProperty(e,"block",{enumerable:!0,get:function(){return t.block}}),Object.defineProperty(e,"build",{enumerable:!0,get:function(){return t.build}}),Object.defineProperty(e,"createSignableVoucher",{enumerable:!0,get:function(){return t.createSignableVoucher}}),Object.defineProperty(e,"decode",{enumerable:!0,get:function(){return t.decode}}),Object.defineProperty(e,"getAccount",{enumerable:!0,get:function(){return t.getAccount}}),Object.defineProperty(e,"getBlock",{enumerable:!0,get:function(){return t.getBlock}}),Object.defineProperty(e,"getBlockHeader",{enumerable:!0,get:function(){return t.getBlockHeader}}),Object.defineProperty(e,"getCollection",{enumerable:!0,get:function(){return t.getCollection}}),Object.defineProperty(e,"getEvents",{enumerable:!0,get:function(){return t.getEvents}}),Object.defineProperty(e,"getEventsAtBlockHeightRange",{enumerable:!0,get:function(){return t.getEventsAtBlockHeightRange}}),Object.defineProperty(e,"getEventsAtBlockIds",{enumerable:!0,get:function(){return t.getEventsAtBlockIds}}),Object.defineProperty(e,"getNetworkParameters",{enumerable:!0,get:function(){return t.getNetworkParameters}}),Object.defineProperty(e,"getNodeVersionInfo",{enumerable:!0,get:function(){return t.getNodeVersionInfo}}),Object.defineProperty(e,"getTransaction",{enumerable:!0,get:function(){return t.getTransaction}}),Object.defineProperty(e,"getTransactionStatus",{enumerable:!0,get:function(){return t.getTransactionStatus}}),Object.defineProperty(e,"invariant",{enumerable:!0,get:function(){return t.invariant}}),Object.defineProperty(e,"isBad",{enumerable:!0,get:function(){return t.isBad}}),Object.defineProperty(e,"isOk",{enumerable:!0,get:function(){return t.isOk}}),Object.defineProperty(e,"limit",{enumerable:!0,get:function(){return t.limit}}),Object.defineProperty(e,"nodeVersionInfo",{enumerable:!0,get:function(){return t.nodeVersionInfo}}),Object.defineProperty(e,"param",{enumerable:!0,get:function(){return t.param}}),Object.defineProperty(e,"params",{enumerable:!0,get:function(){return t.params}}),Object.defineProperty(e,"payer",{enumerable:!0,get:function(){return t.payer}}),Object.defineProperty(e,"ping",{enumerable:!0,get:function(){return t.ping}}),Object.defineProperty(e,"pipe",{enumerable:!0,get:function(){return t.pipe}}),Object.defineProperty(e,"proposer",{enumerable:!0,get:function(){return t.proposer}}),Object.defineProperty(e,"ref",{enumerable:!0,get:function(){return t.ref}}),Object.defineProperty(e,"script",{enumerable:!0,get:function(){return t.script}}),Object.defineProperty(e,"send",{enumerable:!0,get:function(){return t.send}}),Object.defineProperty(e,"subscribeEvents",{enumerable:!0,get:function(){return t.subscribeEvents}}),Object.defineProperty(e,"transaction",{enumerable:!0,get:function(){return t.transaction}}),Object.defineProperty(e,"validator",{enumerable:!0,get:function(){return t.validator}}),Object.defineProperty(e,"voucherIntercept",{enumerable:!0,get:function(){return t.voucherIntercept}}),Object.defineProperty(e,"voucherToTxId",{enumerable:!0,get:function(){return t.voucherToTxId}}),Object.defineProperty(e,"why",{enumerable:!0,get:function(){return t.why}}),e.t=h,Object.defineProperty(e,"config",{enumerable:!0,get:function(){return i.config}}),Object.defineProperty(e,"display",{enumerable:!0,get:function(){return s.display}}),Object.defineProperty(e,"sansPrefix",{enumerable:!0,get:function(){return s.sansPrefix}}),Object.defineProperty(e,"withPrefix",{enumerable:!0,get:function(){return s.withPrefix}}),Object.defineProperty(e,"cadence",{enumerable:!0,get:function(){return f.template}}),Object.defineProperty(e,"cdc",{enumerable:!0,get:function(){return f.template}}),e.AppUtils=ce,e.CORE_STRATEGIES=H,e.FCL_REDIRECT_URL_PARAM_NAME=$,e.FCL_RESPONSE_PARAM_NAME=M,e.InteractionTemplateUtils=et,e.URL=G,e.VERSION=S,e.WalletUtils=ae,e.buildMessageHandler=e=>{let t,{close:n,send:r,onReady:a,onResponse:i,onMessage:o,onCustomRpc:s,getSource:c}=e;return e=>{try{t=c?.()||t}catch(e){t=null}try{if("object"!=typeof e.data)return;if(Ht.has(e.data.type))return;if(null!=t&&e.source!==t)return;Mt(e.data.type)===Mt(Bt)&&n(),Mt(e.data.type)===Mt(zt)&&(a(e,{send:r,close:n}),t||=e.source),Mt(e.data.type)===Mt($t)&&i(e,{send:r,close:n}),Mt(e.data.type)===Mt("FCL:VIEW:CUSTOM_RPC")&&s(e.data.payload,{send:r,close:n}),o(e,{send:r,close:n}),Mt(e.data.type)===Mt("FCL:FRAME:READY")&&(Vt(e.data.type,zt),a(e,{send:r,close:n}),t||=e.source),Mt(e.data.type)===Mt("FCL:FRAME:RESPONSE")&&(Vt(e.data.type,$t),i(e,{send:r,close:n})),Mt(e.data.type)===Mt("FCL:FRAME:CLOSE")&&(Vt(e.data.type,Bt),n()),Mt(e.data.type)===Mt("FCL::CHALLENGE::RESPONSE")&&(Vt(e.data.type,$t),i(e,{send:r,close:n})),Mt(e.data.type)===Mt("FCL::AUTHZ_READY")&&(Vt(e.data.type,zt),a(e,{send:r,close:n}),t||=e.source),Mt(e.data.type)===Mt("FCL::CHALLENGE::CANCEL")&&(Vt(e.data.type,Bt),n()),Mt(e.data.type)===Mt("FCL::CANCEL")&&(Vt(e.data.type,Bt),n())}catch(e){console.error("Frame Callback Error",e),n()}}},e.discovery=Ve,e.events=function(e){let n;return n="string"==typeof e?{eventTypes:[e]}:e||{},{subscribe:r=>{const a=t.send([t.subscribeEvents(n)]).then(t.decode),i=a.then((()=>null)).catch((t=>{if("SDK Send Error: subscribeEvents is not supported by this transport."!==t.message)throw t;if("string"!=typeof e)throw new Error("GRPC fcl.events fallback only supports string (type) filters");return(n=e,{subscribe:e=>l.subscriber(n,Te,e)}).subscribe(r);var n}));function o(e){e.forEach((e=>r(e,null)))}function s(e){r(null,e)}return i.then((e=>{e||a.then((e=>e.on("events",o).on("error",s))).catch((e=>{a.then((e=>e.close())),s(e)}))})),()=>{i.then((e=>{e?e():a.then((e=>e.close()))}))}}}},e.execStrategy=pt,e.getChainId=D,e.getCurrentUser=Nt,e.getExecHttpPost=e=>async t=>{let{service:n,body:r,config:a,opts:i}=t;const o=await Lt(n,{data:{fclVersion:S,service:{params:n.params,data:n.data,type:n.type},config:a,...r}}).then(xt);if("APPROVED"===o.status)return o.data;if("DECLINED"===o.status)throw new Error(`Declined: ${o.reason||"No reason supplied."}`);if("REDIRECT"===o.status)return o;if("PENDING"===o.status){var s=!0,c=!0;const[t,n]=await e(rt(o.local),{serviceEndpoint:jt,onClose:()=>c=!1}),r=()=>{try{n(),c=!1}catch(e){console.error("Frame Close Error",e)}},a=()=>{const e=s;return s=c,e};return Ft(o.updates,a).then((e=>(r(),e))).catch((e=>{throw console.error(e),r(),e}))}throw console.error("Auto Decline: Invalid Response",{service:n,resp:o}),new Error("Auto Decline: Invalid Response")},e.getMutate=e=>{let{platform:t,discovery:n}=e;return async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await async function(e){return B("mutate",e)}(e),e=await F(e);const r=Nt({platform:t,discovery:n}),a=await v.config().get("fcl.authz",r().authorization);return v.send([v.transaction(e.cadence),v.args(O(e.args||[])),e.limit&&R(e.limit)&&v.limit(e.limit),v.proposer(e.proposer||e.authz||a),v.payer(e.payer||e.authz||a),v.authorizations(e.authorizations||[e.authz||a])]).then(v.decode)}catch(e){throw e}}},e.initServiceRegistry=je,e.isReactNative=W,e.normalizePollingResponse=xt,e.pluginRegistry=xe,e.query=z,e.serialize=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await t.config.first(["sdk.resolve"],n.resolve||t.resolve);return Array.isArray(e)&&(e=await t.pipe(t.interaction(),e)),JSON.stringify(t.createSignableVoucher(await r(e)),null,2)},e.serviceEndpoint=jt,e.setIsReactNative=function(e){q=e},e.tx=we,e.verifyUserSignatures=le,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=fcl-core.umd.min.js.map
