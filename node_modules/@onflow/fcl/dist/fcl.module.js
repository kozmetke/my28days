import { execStrategy, normalizePollingResponse, buildMessageHandler, serviceEndpoint, CORE_STRATEGIES, getExecHttpPost, pluginRegistry, getMutate, getCurrentUser, initServiceRegistry } from '@onflow/fcl-core';
export { AppUtils, InteractionTemplateUtils, TestUtils, VERSION, WalletUtils, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, cadence, cdc, config, createSignableVoucher, decode, discovery, display, events, getAccount, getBlock, getBlockHeader, getChainId, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getNetworkParameters, getNodeVersionInfo, getTransaction, getTransactionStatus, invariant, isBad, isOk, limit, nodeVersionInfo, param, params, payer, ping, pipe, pluginRegistry, proposer, query, ref, sansPrefix, script, send, serialize, subscribeEvents, t, transaction, tx, validator, verifyUserSignatures, voucherIntercept, voucherToTxId, why, withPrefix } from '@onflow/fcl-core';
import { RpcClient } from '@onflow/util-rpc';
import * as fclWc from '@onflow/fcl-wc';
import { getSignClient, createSessionProposal, request, FLOW_METHODS } from '@onflow/fcl-wc';
import { config } from '@onflow/config';
import { invariant } from '@onflow/util-invariant';
import { uid } from '@onflow/util-uid';

const AbortController = globalThis.AbortController || require("abort-controller");
function wrapAbortSignal(signal) {
  const controller = new AbortController();
  if (signal?.aborted) controller.abort();
  signal?.addEventListener("abort", () => controller.abort());
  return controller;
}

let DiscoveryNotification = /*#__PURE__*/function (DiscoveryNotification) {
  DiscoveryNotification["NOTIFY_QRCODE_CONNECTING"] = "notifyQrCodeConnecting";
  DiscoveryNotification["NOTIFY_QRCODE_CONNECTED"] = "notifyQrCodeConnected";
  DiscoveryNotification["NOTIFY_QRCODE_ERROR"] = "notifyQrCodeError";
  return DiscoveryNotification;
}({});
let FclRequest = /*#__PURE__*/function (FclRequest) {
  FclRequest["REQUEST_WALLETCONNECT_QRCODE"] = "requestWalletConnectQrCode";
  FclRequest["EXEC_SERVICE"] = "execService";
  return FclRequest;
}({});

const APPROVED = "APPROVED";

// RPC handler for handling service execution requests (e.g extension service)
const execServiceHandlerFactory = _ref => {
  let {
    onExecResult,
    execStrategyOpts,
    execStrategyArgs,
    abortSignal
  } = _ref;
  return async _ref2 => {
    let {
      service
    } = _ref2;
    try {
      const result = await execStrategy({
        ...execStrategyOpts,
        service,
        config: execStrategyOpts.config,
        abortSignal
      },
      // Pass the rest of the arguments (protect against future changes)
      ...execStrategyArgs.slice(1));
      const status = normalizePollingResponse(result)?.status || APPROVED;
      if (status === APPROVED) {
        // Propogrates the result to the execStrategy hook
        onExecResult(result);

        // Notify Discovery that the service was approved
        return null;
      } else {
        // Notify Discovery that the service was rejected
        throw new Error(result?.reason || "Service was declined");
      }
    } catch (e) {
      throw new Error(e?.message || "Service execution failed");
    }
  };
};

// RPC handler for handling WalletConnect QR code requests
const wcRequestHandlerFactory = _ref => {
  let {
    rpc,
    onExecResult,
    authnBody,
    abortSignal
  } = _ref;
  const watchQr = watchQrFactory({
    rpc,
    authnBody
  });
  return async _ref2 => {
    if (abortSignal.aborted) {
      throw new Error("Handler has been terminated");
    }
    const client = await getSignClient();

    // Execute WC bypass if session is approved
    const {
      uri,
      approval
    } = await createSessionProposal({
      client
    });

    // Watch for QR code connection asynchronously
    watchQr({
      uri,
      approval,
      onExecResult
    });
    return {
      uri
    };
  };
};
function watchQrFactory(_ref3) {
  let {
    rpc,
    authnBody
  } = _ref3;
  return _ref4 => {
    let {
      uri,
      approval,
      onExecResult
    } = _ref4;
    // Watch for QR code connection & resolve callback if connected
    setTimeout(async () => {
      try {
        const client = await getSignClient();
        const session = await approval();
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_CONNECTING, {
          uri
        });
        const result = await request({
          method: FLOW_METHODS.FLOW_AUTHN,
          body: authnBody,
          session,
          client
        });
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_CONNECTED, {
          uri
        });
        onExecResult(result);
      } catch (e) {
        rpc.notify(DiscoveryNotification.NOTIFY_QRCODE_ERROR, {
          uri,
          error: e?.message
        });
      }
    }, 0);
  };
}

// Initialize the discovery RPC client
function createDiscoveryRpcClient(_ref) {
  let {
    onExecResult,
    body,
    opts,
    args,
    abortSignal
  } = _ref;
  const rpc = new RpcClient({
    notifications: []
  });
  rpc.on(FclRequest.REQUEST_WALLETCONNECT_QRCODE, wcRequestHandlerFactory({
    rpc,
    onExecResult,
    authnBody: body,
    abortSignal
  }));
  rpc.on(FclRequest.EXEC_SERVICE, execServiceHandlerFactory({
    onExecResult,
    execStrategyOpts: opts,
    execStrategyArgs: args,
    abortSignal
  }));
  return {
    connect: rpc.connect.bind(rpc),
    receive: rpc.receive.bind(rpc)
  };
}

async function execDiscovery(_ref) {
  let {
    customRpc,
    opts,
    args,
    abortSignal
  } = _ref;
  // Update the discovery config to enable RPC support
  const discoveryConfig = {
    ...opts.config,
    client: {
      ...opts.config.client,
      discoveryRpcEnabled: true
    }
  };

  // Execute base discovery request
  return execStrategy({
    ...opts,
    config: discoveryConfig,
    customRpc,
    abortSignal
  },
  // @ts-ignore - Pass the rest of the arguments (protect against future changes)
  ...args.slice(1));
}

const AUTHN_SERVICE_TYPE = "authn";

// Defines the execStrategy hook for Discovery Service
// Used to define custom service execution rules for the Discovery Service
async function execStrategyHook() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  const [opts] = args;
  const {
    body,
    abortSignal: baseAbortSignal,
    service
  } = opts;

  // Ensure the service type is "auth" for the execStrategyHook
  if (service?.type !== AUTHN_SERVICE_TYPE) {
    console.error(`ERROR: Invalid service type for FCL Discovery execStrategyHook, expected "${AUTHN_SERVICE_TYPE}" but got "${service?.type}"`);
    return execStrategy(...args);
  }

  // Create an abort controller for this context
  // Either used to terminate WC bypass proposal loop or the base discovery request
  const abortController = wrapAbortSignal(baseAbortSignal);
  let discoveryPromise;
  const resultPromise = new Promise(async (resolve, reject) => {
    // Initialize the discovery RPC client
    const rpc = createDiscoveryRpcClient({
      onExecResult: resolve,
      body,
      opts,
      args,
      abortSignal: abortController.signal
    });

    // Execute the base discovery request
    discoveryPromise = execDiscovery({
      customRpc: rpc,
      opts,
      args,
      abortSignal: abortController.signal
    }).then(resolve, reject);
  });

  // Wait for the result promise to resolve or reject
  await resultPromise.catch(() => {});

  // Give Discovery time to cleanup
  await Promise.race([new Promise(resolve => setTimeout(resolve, 1000)), discoveryPromise]).catch(() => {});

  // Ensure the abort signal is propagated to all candidates on completion
  abortController.abort();

  // Return the result
  return resultPromise;
}

const FRAME = "FCL_IFRAME";
const FRAME_STYLES = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
  color-scheme: light;
`;
function renderFrame(src) {
  invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src
  });
  const $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *; clipboard-write";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);
  const unmount = () => {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };
  return [$frame.contentWindow, unmount];
}

const POP = "FCL_POP";
let popup = null;
let previousUrl$1 = null;
function popupWindow(url, windowName, win, w, h) {
  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);
  if (!popup) throw new Error("Popup failed to open (was it blocked by a popup blocker?)");
  return popup;
}
function renderPop(src) {
  if (popup == null || popup?.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }
  previousUrl$1 = src;
  const unmount = () => {
    if (popup && !popup.closed) {
      popup.close();
    }
    popup = null;
  };
  return [popup, unmount];
}

let tab$1 = null;
let previousUrl = null;
function renderTab(src) {
  if (tab$1 == null || tab$1?.closed) {
    tab$1 = window.open(src, "_blank");
    if (!tab$1) throw new Error("Tab failed to open (was it blocked by the browser?)");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }
  previousUrl = src;
  const unmount = () => {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }
    tab$1 = null;
  };
  return [tab$1, unmount];
}

const isServerSide = () => typeof window === "undefined";
const getSessionStorage = () => {
  try {
    const SESSION_STORAGE = {
      can: !isServerSide(),
      get: async key => JSON.parse(sessionStorage.getItem(key)),
      put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))
    };
    return SESSION_STORAGE;
  } catch (error) {
    return null;
  }
};
const getDefaultConfig = () => {
  return {
    "discovery.wallet.method.default": "IFRAME/RPC",
    "fcl.storage.default": getSessionStorage()
  };
};

const noop$3 = () => {};
function frame(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  const onClose = opts.onClose || noop$3;
  const onMessage = opts.onMessage || noop$3;
  const onReady = opts.onReady || noop$3;
  const onResponse = opts.onResponse || noop$3;
  const onCustomRpc = opts.onCustomRpc || noop$3;
  let $frame, unmount;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $frame
  });
  window.addEventListener("message", handler);
  [$frame, unmount] = renderFrame(serviceEndpoint(service));
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }
  function send(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}

const VERSION = "1.12.3" ;

function execIframeRPC(_ref) {
  let {
    service,
    body,
    config,
    customRpc,
    abortSignal,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    const {
      close
    } = frame(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            type: "FCL:VIEW:READY:RESPONSE",
            fclVersion: VERSION,
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params],
              deprecated: {
                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        reject(`Declined: Aborted`);
        close();
      }
      abortSignal.addEventListener("abort", () => {
        reject(`Declined: Aborted`);
        close();
      });
    }
  });
}

const noop$2 = () => {};
function pop(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  const onClose = opts.onClose || noop$2;
  const onMessage = opts.onMessage || noop$2;
  const onReady = opts.onReady || noop$2;
  const onResponse = opts.onResponse || noop$2;
  const onCustomRpc = opts.onCustomRpc || noop$2;
  let $pop, unmount;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $pop
  });
  window.addEventListener("message", handler);
  [$pop, unmount] = renderPop(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($pop && $pop.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }
  function send(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}

function execPopRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    const {
      close
    } = pop(service, {
      customRpc,
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        reject(`Declined: Aborted`);
        close();
      }
      abortSignal.addEventListener("abort", () => {
        reject(`Declined: Aborted`);
        close();
      });
    }
  });
}

const noop$1 = () => {};
function tab(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  const onClose = opts.onClose || noop$1;
  const onMessage = opts.onMessage || noop$1;
  const onReady = opts.onReady || noop$1;
  const onResponse = opts.onResponse || noop$1;
  const onCustomRpc = opts.onCustomRpc || noop$1;
  let $tab, unmount;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc,
    getSource: () => $tab
  });
  window.addEventListener("message", handler);
  [$tab, unmount] = renderTab(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($tab && $tab.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }
  function send(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}

function execTabRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    const {
      close
    } = tab(service, {
      customRpc,
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                payload: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        close();
        reject(`Declined: Aborted`);
      }
      abortSignal.addEventListener("abort", () => {
        close();
        reject(`Declined: Aborted`);
      });
    }
  });
}

const noop = () => {};
function extension(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop,
    close: noop
  };
  const onClose = opts.onClose || noop;
  const onMessage = opts.onMessage || noop;
  const onReady = opts.onReady || noop;
  const onResponse = opts.onResponse || noop;
  const onCustomRpc = opts.onCustomRpc || noop;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage,
    onCustomRpc
  });
  window.addEventListener("message", handler);
  send({
    service
  });
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }
  function send(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}

function execExtRPC(_ref) {
  let {
    service,
    body,
    config,
    abortSignal,
    customRpc,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const {
      close
    } = extension(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          customRpc?.connect({
            send: msg => {
              send({
                type: "FCL:VIEW:CUSTOM_RPC",
                body: msg
              });
            }
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      },
      onCustomRpc(msg) {
        customRpc?.receive(msg);
      }
    });
    if (abortSignal) {
      if (abortSignal.aborted) {
        close();
        reject(`Declined: Aborted`);
      }
      abortSignal.addEventListener("abort", () => {
        close();
        reject(`Declined: Aborted`);
      });
    }
  });
}

const NOT_IMPLEMENTED = () => {
  throw new Error("Strategy util has not been implemented on this platform");
};
const VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab,
  "VIEW/MOBILE_BROWSER": NOT_IMPLEMENTED,
  "VIEW/DEEPLINK": NOT_IMPLEMENTED
};
async function execLocal(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    serviceEndpoint: () => {}
  };
  const {
    serviceEndpoint
  } = opts;
  try {
    return VIEWS[service.method](serviceEndpoint(service), opts);
  } catch (error) {
    console.error("execLocal({service, opts = {}})", error, {
      service,
      opts
    });
    throw error;
  }
}

const coreStrategies = {
  [CORE_STRATEGIES["HTTP/RPC"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["HTTP/POST"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["IFRAME/RPC"]]: execIframeRPC,
  [CORE_STRATEGIES["POP/RPC"]]: execPopRPC,
  [CORE_STRATEGIES["TAB/RPC"]]: execTabRPC,
  [CORE_STRATEGIES["EXT/RPC"]]: execExtRPC
};

const isServer = typeof window === "undefined";
const getMetadata = config => {
  const appTitle = config["app.detail.title"];
  const appIcon = config["app.detail.icon"];
  const appDescription = config["app.detail.description"];
  const appUrl = config["app.detail.url"];
  return {
    name: appTitle ?? document.title,
    description: appDescription ?? "",
    url: appUrl ?? window.location.origin,
    icons: appIcon ? [appIcon] : []
  };
};
function initFclWcLoader() {
  // We cannot load WalletConnect plugin on server side
  if (isServer) {
    return;
  }

  // Use previous configuration to check for changes & notify the user that this is not possible
  let lastConfig = null;

  // Only the first configuration will be used
  let hasLoaded = false;
  config.subscribe(async fullConfig => {
    const wcConfig = {
      "walletconnect.projectId": fullConfig["walletconnect.projectId"],
      "app.detail.title": fullConfig["app.detail.title"],
      "app.detail.icon": fullConfig["app.detail.icon"],
      "app.detail.description": fullConfig["app.detail.description"],
      "app.detail.url": fullConfig["app.detail.url"]
    };
    const projectId = wcConfig["walletconnect.projectId"];

    // Check if the plugin is already loaded by this loader, but with different configuration
    // The plugin can only be loaded once
    const previousConfig = lastConfig;
    lastConfig = JSON.stringify(wcConfig, null, 2);
    if (hasLoaded) {
      if (previousConfig !== lastConfig) {
        console.warn(`FCL WalletConnect Plugin has been already loaded with different configuration. It is not possible to change the configuration after the plugin has been loaded.

Previous configuration:
${previousConfig}

Current configuration:
${lastConfig}`);
      }
      return;
    }

    // If the configuration is not set, we do not load the plugin
    const isConfigured = !!projectId;
    if (!isConfigured) {
      return;
    }
    invariant(!!projectId, "FCL Configuration value for 'walletconnect.projectId' is required");

    // Check if the plugin is already loaded manually
    // Usually this won't happen as it is more likely that the plugin will be loaded by this loader
    // before the developer has a chance to load it manually, but it's good to check
    if (pluginRegistry.getPlugins().has(fclWc.SERVICE_PLUGIN_NAME)) {
      if (!hasLoaded) {
        console.warn("It seems like the FCL WalletConnect plugins has been already loaded manually. This is no longer necessary, please see the documentation for more information.");
      }
      hasLoaded = true;
      return;
    }
    hasLoaded = true;

    // Load the plugin if not already loaded
    // We must lazy load the plugin to avoid race conditions
    // where the developer attempts to use the plugin before
    // our loader applies the configuration
    const {
      clientPromise: _clientPromise,
      FclWcServicePlugin
    } = fclWc.initLazy({
      projectId,
      metadata: getMetadata(wcConfig)
    });
    pluginRegistry.add([FclWcServicePlugin]);
  });
}

const discoveryOpts = {
  execStrategy: execStrategyHook
};
const mutate = getMutate({
  platform: "web",
  discovery: discoveryOpts
});
const currentUser = getCurrentUser({
  platform: "web",
  discovery: discoveryOpts
});
const authenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const unauthenticate = () => currentUser().unauthenticate();
const reauthenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  currentUser().unauthenticate();
  return currentUser().authenticate(opts);
};
const signUp = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const logIn = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const authz = currentUser().authorization;
config(getDefaultConfig());
initServiceRegistry({
  coreStrategies
});

// Automatically load fcl-wc plugin
// Based on the user's config
initFclWcLoader();

export { authenticate, authz, currentUser, logIn, mutate, reauthenticate, signUp, unauthenticate };
//# sourceMappingURL=fcl.module.js.map
